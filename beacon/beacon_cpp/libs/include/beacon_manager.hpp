#pragma once
//------------------------------------------------------------------------------
//
//   Copyright 2018-2020 Fetch.AI Limited
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//------------------------------------------------------------------------------
#include <memory>
#include <set>
#include <unordered_map>
#include <unordered_set>
#include <vector>

namespace fetch {
namespace crypto {

namespace mcl {
  class PrivateKey;    
  class Signature;
  class PublicKey;
  class Generator;
}

class BeaconManager
{
public:
  using Address          = std::string;
  using PrivateKey       = mcl::PrivateKey;
  using Signature        = mcl::Signature;
  using PublicKey        = mcl::PublicKey;
  using Generator        = mcl::Generator;
  using CabinetIndex     = uint64_t;
  using Share            = std::string;
  using Coefficient      = std::string;
  using ComplaintAnswer  = std::pair<Address, std::pair<Share, Share>>;
  using ExposedShare     = std::pair<Address, std::pair<Share, Share>>;
  using SharesExposedMap = std::unordered_map<Address, std::pair<Share, Share>>;

  explicit BeaconManager(Address address);

  BeaconManager(BeaconManager const &) = delete;
  BeaconManager &operator=(BeaconManager const &) = delete;
  ~BeaconManager();

  void                     GenerateCoefficients();
  std::vector<Coefficient> GetCoefficients();
  std::pair<Share, Share>  GetOwnShares(Address const &receiver);
  std::pair<Share, Share>  GetReceivedShares(Address const &owner);
  void AddCoefficients(Address const &from, std::vector<Coefficient> const &coefficients);
  void AddShares(Address const &from, std::pair<Share, Share> const &shares);
  std::set<Address> ComputeComplaints(std::set<Address> const &coeff_received);
  bool VerifyComplaintAnswer(Address const &from, ComplaintAnswer const &answer);
  void ComputeSecretShare();
  std::vector<Coefficient> GetQualCoefficients();
  void AddQualCoefficients(Address const &from, std::vector<Coefficient> const &coefficients);
  SharesExposedMap ComputeQualComplaints(std::set<Address> const &coeff_received);
  Address    VerifyQualComplaint(Address const &from, ComplaintAnswer const &answer);
  void             ComputePublicKeys();
  void             AddReconstructionShare(Address const &address);
  void             VerifyReconstructionShare(Address const &from, ExposedShare const &share);
  bool             RunReconstruction();
  void             SetQual(std::set<Address> qual);
  void             NewCabinet(std::set<Address> const &cabinet, uint32_t threshold);
  void             Reset();

  /// Property methods
  /// @{
  bool                           InQual(Address const &address) const;
  std::set<Address> const &qual() const;
  uint32_t                       polynomial_degree() const;
  CabinetIndex                   cabinet_index() const;
  CabinetIndex                   cabinet_index(Address const &address) const;
  std::string                    group_public_key() const;
  ///}
  //

private:
  // What the DKG should return
  std::string            secret_share_;       ///< Share of group private key (x_i)
  std::string            public_key_;         ///< Group public key (y)
  std::vector<std::unique_ptr<PublicKey>>  public_key_shares_;  ///< Public keys of cabinet generated by DKG (v_i)
  std::set<Address> qual_;               ///< Set of qualified members

  static Generator const & GetGroupG();
  static Generator const & GetGroupH();
  static PrivateKey const &GetZeroFr();

  Address        address_;
  uint32_t       cabinet_size_;       ///< Size of cabinet
  uint32_t       polynomial_degree_;  ///< Degree of polynomial in DKG
  CabinetIndex   cabinet_index_;      ///< Index of our address in cabinet_

  /// Member details
  /// @{
  std::unordered_map<Address, CabinetIndex> identity_to_index_;
  /// @}

  // Temporary for DKG construction
  std::vector<std::unique_ptr<PublicKey>>               y_i;
  std::vector<std::vector<std::unique_ptr<PrivateKey>>> s_ij, sprime_ij;  ///< Secret shares
  std::vector<std::vector<std::unique_ptr<PublicKey>>>  C_ik;  ///< Verification vectors from cabinet members
  std::vector<std::vector<std::unique_ptr<PublicKey>>>  A_ik;  ///< Qual verification vectors
  std::vector<std::vector<std::unique_ptr<PublicKey>>>  g__s_ij;
  std::vector<std::unique_ptr<PublicKey>>             g__a_i;

  std::unordered_map<Address, std::pair<std::set<CabinetIndex>, std::vector<std::unique_ptr<PrivateKey>>>>
      reconstruction_shares;  ///< Map from id of node_i in complaints to a pair <parties which
  ///< exposed shares of node_i, the shares that were exposed>


  void AddReconstructionShare(Address const &                  from,
                              std::pair<Address, Share> const &share);
};
}  // namespace dkg
}  // namespace fetch
